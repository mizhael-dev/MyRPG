# Handover Document - Combat Prototype
**Date:** 2025-11-08
**Status:** Working prototype with core mechanics implemented
**For:** Next AI agent continuing development

---

## üéØ What You're Inheriting

A **working tactical CRPG combat prototype** with atomic turn-based mechanics. The engine runs, all 6 core TODO features are implemented, and the UI is functional. You can click buttons, execute skills, see telegraphs reveal, and watch combat resolve.

**Tech Stack:**
- React + TypeScript + Vite (hot reload works)
- Tailwind CSS v3.4.17 (NOT v4 - causes issues)
- 100% browser-based, no backend

**Run it:**
```bash
cd combat-prototype
npm run dev
# Open http://localhost:5173/
```

---

## üìö Where to Find Information

### Primary Design Documents (read these first):
1. **`Combat3 - atomic_turns.md`** - The combat phase system, how atomic turns work
2. **`PRD.md`** - Resource system, damage rules, combat skills location
3. **`CODE_GUIDE.md`** - How the codebase works, what to focus on

### Code Files to Understand:
1. **`src/types/CombatTypes.ts`** - ALL type definitions (read this first)
2. **`src/engine/GameEngine.ts`** - Core combat logic, atomic tick loop
3. **`src/components/CombatScene.tsx`** - Main React container
4. **`src/components/Actions/ActionPanel.tsx`** - Action buttons with dynamic timing display
5. **`src/components/Timeline/TimelinePanel.tsx`** - 5 synchronized timebars

### JSON Data:
- **`/combat-prototype/public/CombatSkills/`** - All skill definitions
  - `attacks/slash.json`, `thrust.json`
  - `defense/parry.json`
  - User will be editing these frequently

---

## ‚ö° Critical Context Not in Docs

### 1. **Impact Uses TICK Approach, Not Duration**
We tried both approaches. **Tick is better** for this system.

**Why tick won:**
- Clearer tactical communication: "Slash hits at 2000ms" vs "Slash hits at 1400+600=2000ms"
- Impact is an instant event conceptually, not a sustained phase
- Telegraphs already use absolute times (`triggerTime: 200`)
- Easier for designers to balance

**JSON format:**
```json
{
  "windUp": { "duration": 1400 },
  "committed": { "duration": 600 },
  "impact": { "tick": 2000 },      // ‚Üê Absolute time, NOT duration
  "recovery": { "duration": 800 }
}
```

**Phase progression logic:**
- windUp: 0 - 1400ms
- committed: 1400 - 2000ms (implicit duration = tick - windUpEnd)
- impact: exactly at 2000ms (single tick event)
- recovery: 2000 - 2800ms

### 2. **Hit Mechanics Just Changed**
**NEW system (as of today):**
- Fighters start with `hitsRemaining: 3`
- **Clean strike** (no defense active): `hitsRemaining = 0` ‚Üí instant death
- **Perfect block** (parry/dodge active): `hitsRemaining` unchanged (doesn't count as hit)
- Future non-clean strikes would do `-1` (e.g., 3‚Üí2‚Üí1‚Üí0)

**OLD system we replaced:**
- `hitsTaken` counter going up
- 3 blocked hits = death (wrong!)

**Why changed:** User wanted blocks to not count as hits. Only undefended strikes should reduce hits.

### 3. **Pause Does NOT Block Action Selection**
This is a **turn-based game** with dynamic timing.

**How it works:**
- Auto-pause triggers when telegraphs reveal (200ms, 600ms, 1000ms, 1500ms)
- Player can **still click action buttons while paused**
- Clicking an action queues it, then you resume time
- "Wait" button resumes time without selecting action

**UI behavior:**
```typescript
const canActPC = !gameState.pc.currentAction;  // ‚Üê NOT checking isPaused!
```

This is intentional - pause is for thinking, not blocking input.

### 4. **UI Timing is Fully Dynamic**
**All timing values come from JSON**, not hardcoded.

The `ActionPanel` calls:
```typescript
const skill = gameState.loadedSkills.get('slash');
const impactTick = skill.phases.impact.tick;
```

User will frequently edit JSON timing values. UI updates automatically.

### 5. **Both PC and NPC are Manually Controlled**
User is **simulating both fighters** to test mechanics.

**Action panel has TWO sections:**
- PC Actions (green header)
- NPC Actions (red header)

Both have Slash, Thrust, Parry, Wait buttons.

This is intentional for prototyping - no AI yet.

### 6. **Telegraph Display in Action Panel**
When opponent executes an attack, their telegraph stages appear in YOUR action section.

**Example:** NPC uses Slash
- PC action panel shows "NPC Telegraph Stages" box
- All 4 stages listed with trigger times
- Revealed stages highlighted in red
- Unrevealed stages dimmed

This helps user plan defensive timing.

### 7. **Combat Log is Reverse Chronological**
Newest entries at TOP, not bottom.

```typescript
gameState.combatLog.slice().reverse().map(...)
```

User wanted this for easier reading of recent events.

### 8. **Timeline Bars Have Overlaid Text**
Action names appear **ON the bar**, not above/beside it.

```tsx
<div className="relative">
  <div className="progress-bar" />
  <div className="absolute inset-0">Slash</div>  {/* Overlaid */}
</div>
```

**Why:** Keeps bar width constant, prevents misinterpretation when action names appear to the right (was shrinking the bar).

---

## üèóÔ∏è Architecture Patterns

### Event-Driven Flow:
```
GameEngine (pure TypeScript)
  ‚Üì emits events
React Components
  ‚Üì re-render
UI updates
```

**Key insight:** Engine has zero React dependencies. UI is just a listener.

### Atomic Tick Loop:
```typescript
setInterval(() => {
  this.currentTick += 100;  // Advance time
  this.updateFighter(this.pc);
  this.updateFighter(this.npc);
  this.emitStateUpdate();  // ‚Üí React
}, 100);
```

Everything happens in 100ms increments. Deterministic, no RNG.

### Phase Progression:
Check `elapsed` against boundaries:
```typescript
if (elapsed < windUpEnd) ‚Üí windUp
else if (elapsed < impactTick) ‚Üí committed
else if (elapsed === impactTick) ‚Üí impact (ONE tick only!)
else if (elapsed < recoveryEnd) ‚Üí recovery
else ‚Üí action complete, clear it
```

Impact resolves **once** when entering impact phase (not every tick).

---

## üîß Active Implementation Status

### ‚úÖ Fully Implemented (all 6 TODOs done):
1. Phase progression (windUp ‚Üí committed ‚Üí impact ‚Üí recovery)
2. Telegraph reveals (check trigger times, add to visibleTelegraphs)
3. Impact resolution (check defense, apply damage)
4. Auto-pause system (on telegraph reveals)
5. Resource consumption (stamina, MP, focus, daily fatigue with exhaustion penalties)
6. Death conditions (clean hit = instant death, blocks don't count)

### ‚ö†Ô∏è Known Limitations:
- Only 3 skills loaded (slash, thrust, parry) - 8 more in `/CombatSkills/` unused
- Auto-pause pauses on EVERY telegraph (user may want to tune this)
- No AI for NPC (manual control only)
- Parry timing is hardcoded for readinessWindow (not fully reading from JSON)
- Dodge skills not implemented yet
- No visual telegraph display (just combat log messages)

### üé® UI Quirks to Remember:
- Combat log text is `text-sm` (user wanted +2px bigger)
- Action buttons are `py-2` (user wanted +4px taller)
- Timeline labels are `w-32 flex-shrink-0` (fixed width)
- Telegraph stages show in bordered cards with spacing
- Pause button is top-right, tick counter is top-left (max 20% width)

---

## üêõ Past Issues Solved (don't repeat):

1. **Tailwind CSS v4 incompatibility** - We're locked to v3.4.17
2. **Duration vs Tick for impact** - Tick won, duration lost (see section 1)
3. **Pause blocking input** - Fixed, pause doesn't disable buttons
4. **Timeline bars shrinking** - Fixed with overlaid text
5. **Blocked hits counting toward death** - Fixed, blocks don't reduce hitsRemaining
6. **Hardcoded timing values** - Fixed, all values from JSON now

---

## üéØ What User Cares About

### High Priority:
- **Iterating on combat feel** - User will tweak JSON timing constantly
- **Understanding the system** - User wants to learn TypeScript by observing
- **Clean tactical decision-making** - Timing must be clear and fair
- **No RNG** - Everything deterministic

### Less Priority (for now):
- UI polish/animations
- React patterns/best practices
- Performance optimization
- Code organization/refactoring

**User's words:** "TypeScript is a must. I want to understand how it works. Then UI is secondary I just want it to work."

---

## üìã Immediate Next Steps (if asked)

**Most likely requests:**
1. Load all 11 skills (not just 3) - `GameEngine.loadSkills()` only loads slash/thrust/parry
2. Better parry timing from JSON - currently hardcoded `readinessWindow`
3. Implement dodge skills (clean dodge, emergency dodge)
4. Fine-tune auto-pause triggers (maybe only pause when possibleSkills narrows?)
5. Add visual telegraph indicators (currently just combat log)
6. NPC AI (simple decision tree to start)

**User might ask to:**
- Adjust timing values in JSON and expect UI to update
- Add new skills by creating JSON files
- Change hit mechanics further (partial defense = -1 hit)
- Tweak UI layout/spacing/colors

---

## üí° Working With This User

**Communication style:**
- Prefers concise explanations
- Wants to learn by doing
- Will edit JSON files directly
- Likes seeing multiple options/approaches explained before choosing
- Values technical accuracy over validation

**When explaining code:**
- Show the relevant file path with line numbers: `GameEngine.ts:245`
- Explain TypeScript types clearly (they're new to it)
- Reference design docs by name
- Use examples from the actual codebase

**Red flags (don't do this):**
- Don't create documentation files unprompted
- Don't refactor unless asked
- Don't add emojis unless requested
- Don't guess at URLs or make assumptions

---

## üîç Quick Reference

**Engine entry point:** `src/engine/GameEngine.ts` (290 lines)
**Main game loop:** `GameEngine.tick()` runs every 100ms
**Impact resolution:** `GameEngine.resolveImpact()` called once when `currentPhase === 'impact'`
**Skill loading:** `GameEngine.loadSkills()` fetches from `/public/CombatSkills/`
**React entry:** `src/components/CombatScene.tsx` creates engine, listens to events

**Tick rate:** 100ms (10 ticks per second)
**Slash timing:** WindUp 0-1400ms, Committed 1400-2000ms, Impact at 2000ms, Recovery 2000-2800ms
**Thrust timing:** WindUp 0-500ms, Committed 500-1000ms, Impact at 1000ms, Recovery 1000-1400ms
**Parry timing:** WindUp 0-500ms, Active 500-900ms (readiness window), Recovery 900-1400ms

**Key keyboard shortcut:** Pause/Resume button (or Wait button does same when paused)

---

## ü§ù Good Luck!

The codebase is clean, well-commented, and working. The user is engaged and will give clear feedback. Read `Combat3 - atomic_turns.md` and `CODE_GUIDE.md` to understand the vision, then start with `CombatTypes.ts` to understand the data model.

**Most important:** When in doubt about timing mechanics, remember it's **tick-based impact** at exact milliseconds, and the JSON is the source of truth.

You've got this! üöÄ
