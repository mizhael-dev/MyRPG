# Handover Document - Combat Prototype

**Date:** 2025-11-11
**Status:** HP-based damage system complete, defense timing system implemented, delayed tick interval start implemented
**For:** Next AI agent continuing development

---

## üéØ What You're Inheriting

A **working tactical CRPG combat prototype** with a **complete HP-based damage system** and **50ms atomic tick intervals**. The core engine runs, skills are data-driven from CSV files, and the UI shows both fighters' actions side-by-side.

**Recent Major Changes:**

- ‚úÖ Legacy "clean hit" system completely removed
- ‚úÖ HP-based damage system fully implemented (3 HP, 3 damage, death at HP <= 0)
- ‚úÖ Damage formula with defense reduction: `attackDamage * (1 - damageReductionPercent) - damageReductionFlat`
- ‚úÖ Tick interval changed from 100ms to 50ms for better timing precision
- ‚úÖ Defense active window checking fixed (time-based, not phase-based)
- ‚úÖ Delayed tick interval start: combat timer only starts when first action is taken

**Tech Stack:**

- React + TypeScript + Vite (hot reload works)
- Tailwind CSS v3.4.17 ‚ö†Ô∏è (LOCKED - v4 causes issues, never upgrade)
- Node.js build scripts (CommonJS)
- 100% browser-based, no backend

**Run it:**

```bash
cd combat-prototype
npm run dev          # Start dev server at http://localhost:5173/
npm run build:skills # Rebuild all skills from CSV
npm run validate:skills # Check CSV without writing files
```

---

## üìÇ Project Structure

```
MyRPG/
‚îú‚îÄ‚îÄ combat-prototype/                    # Main combat prototype
‚îÇ   ‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ assets/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ telegraphs/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ README.md           # Asset management guide
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CombatSkills/               # Skill data (CSV + JSON)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ README.md               # **START HERE** - CSV workflow guide
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ attacks/
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ CombatSkills-attack.csv     # Source of truth for attacks
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ diagonal_slash.json         # Generated
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ overhead_strike.json        # Generated
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ side_slash.json             # Generated
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ thrust.json                 # Generated
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ upward_strike.json          # Generated
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ defense/
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ CombatSkills-defense.csv    # Source of truth for defenses
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ CombatSkills-defense.md     # Defense skill designs
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ deflection.json             # Generated
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ emergency_defense.json      # Generated
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ parry.json                  # Generated
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ retreat.json                # Generated
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ special/
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ CombatSkills-special.csv    # Source of truth for specials
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ feint.json                  # Generated
‚îÇ   ‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ buildSkills.cjs             # CSV‚ÜíJSON build system (~580 lines, heavily commented)
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Actions/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ActionPanel.tsx     # Action buttons (left/right panels)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Timeline/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TimelinePanel.tsx   # 5 synchronized timebars
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CombatScene.tsx         # Main container (3-column layout)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ViewModeSelector.tsx    # View mode toggle
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ engine/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GameEngine.ts           # **CORE** - Combat logic, atomic tick loop (~811 lines)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CombatTypes.ts          # **START HERE** - ALL type definitions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.tsx                     # React app entry
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.tsx                    # Vite entry
‚îÇ   ‚îú‚îÄ‚îÄ package.json                    # Dependencies
‚îÇ   ‚îú‚îÄ‚îÄ tsconfig.json                   # TypeScript config
‚îÇ   ‚îî‚îÄ‚îÄ vite.config.ts                  # Vite config
‚îú‚îÄ‚îÄ extra_context/                      # Historical docs
‚îÇ   ‚îú‚îÄ‚îÄ 20251108_handover.md
‚îÇ   ‚îú‚îÄ‚îÄ Combat3 - TechStack.md
‚îÇ   ‚îî‚îÄ‚îÄ SETUP_GUIDE.md
‚îú‚îÄ‚îÄ Backlog-Later/                      # Future features
‚îÇ   ‚îú‚îÄ‚îÄ Player_Character_Sheet.md
‚îÇ   ‚îî‚îÄ‚îÄ Resource System.md
‚îú‚îÄ‚îÄ .claude/                            # Claude Code settings
‚îÇ   ‚îî‚îÄ‚îÄ commands/
‚îÇ       ‚îú‚îÄ‚îÄ handover.md                 # This command
‚îÇ       ‚îî‚îÄ‚îÄ onboard.md
‚îú‚îÄ‚îÄ 20251110_handover.md                # Previous handover
‚îú‚îÄ‚îÄ 20251110_defensive_skills_implementation.md  # Defense implementation notes
‚îú‚îÄ‚îÄ 20251111_1_handover.md              # **THIS FILE**
‚îú‚îÄ‚îÄ Atomic_Turns.md                     # Early atomic turn design
‚îú‚îÄ‚îÄ Claude_Summary.md                   # Project vision & design analysis
‚îú‚îÄ‚îÄ CODE_GUIDE.md                       # How the codebase works
‚îú‚îÄ‚îÄ Combat3 - atomic_turns.md           # **ESSENTIAL** - Phase system, atomic turns
‚îú‚îÄ‚îÄ CombatSkillData-DesignDoc.md        # Skill data design
‚îú‚îÄ‚îÄ PRD.md                              # **ESSENTIAL** - Resource system, damage rules
‚îú‚îÄ‚îÄ CLAUDE.md                           # User instructions for AI agents
‚îú‚îÄ‚îÄ package.json                        # Root dependencies
‚îî‚îÄ‚îÄ README.md                           # Combat prototype readme
```

---

## üìö Reading List (Read in Order)

### Essential Reading (Start Here):

1. **`CLAUDE.md`** - User instructions and working agreements
   - How to work with this user
   - React best practices
   - Be skeptical, do research

2. **`Combat3 - atomic_turns.md`** - The combat phase system
   - 50ms atomic tick system
   - Phase progression (windUp ‚Üí committed ‚Üí impact ‚Üí recovery)
   - Telegraph mechanics
   - Defense timing windows

3. **`PRD.md`** - Product requirements document
   - HP-based damage system (lines 182-203)
   - Resource system (4-layer design)
   - Combat skills definitions
   - Current implementation status

4. **`combat-prototype/src/types/CombatTypes.ts`** - ALL type definitions
   - FighterState, ActionState, GameState
   - CombatSkill structure
   - Phase types
   - Defense properties

5. **`combat-prototype/src/engine/GameEngine.ts`** - Core combat logic
   - Atomic tick loop (runs every 50ms)
   - Phase progression (lines 303-396)
   - Impact resolution (lines 441-497)
   - Defense active window checking (lines 503-522)
   - executeSkill() with delayed tick start (lines 613-720)

6. **`combat-prototype/public/CombatSkills/README.md`** - CSV workflow guide
   - How to edit skills via CSV
   - Build system workflow
   - Auto-calculated fields

### Recent Changes & Context:

7. **`20251110_handover.md`** - Previous handover document
   - CSV build system details
   - UI layout (3-column)
   - Defense skill structure
   - Past issues solved

8. **`20251110_defensive_skills_implementation.md`** - Defense implementation notes
   - Parry line selection UI
   - Deflection attack prediction
   - Emergency defense damage model
   - Retreat movement mechanics

9. **`CODE_GUIDE.md`** - How the codebase works
   - Architecture patterns
   - File organization
   - Key functions

### Secondary Reading (Reference):

10. **`Claude_Summary.md`** - Project vision & design analysis
    - Grimdark tactical CRPG
    - No RNG philosophy
    - Character system
    - Resource cascade

11. **`combat-prototype/scripts/buildSkills.cjs`** - CSV‚ÜíJSON build system
    - Heavily commented (~580 lines)
    - Auto-calculation logic
    - Validation rules
    - Asset checking

12. **`combat-prototype/public/CombatSkills/defense/CombatSkills-defense.md`** - Defense skill designs
    - Defense mechanics by type
    - Timing windows
    - Counter mechanics

---

## ‚ö° Critical Context Not in Docs

### 1. **HP-Based Damage System (RECENTLY IMPLEMENTED)**

**All references to "clean hit" and "hitsRemaining" have been removed.**

**Current System:**

- Both PC and NPC: **3 HP**
- All attacks: **3 base damage**
- Death condition: **HP <= 0**

**Damage Formula:**

```typescript
finalDamage = attackDamage * (1 - damageReductionPercent) - damageReductionFlat;
if (finalDamage < 0) finalDamage = 0;
```

**Defense Damage Reduction:**

- Emergency Defense: 2 flat reduction ‚Üí 1 damage taken (3 - 2 = 1)
- Retreat: 100% reduction ‚Üí 0 damage (full dodge)
- Parry: 3 flat reduction ‚Üí 0 damage (3 - 3 = 0)
- Deflection: 3 flat reduction ‚Üí 0 damage (3 - 3 = 0)

**Implementation:** `GameEngine.ts:441-497` (resolveImpact method)

### 2. **50ms Tick Interval (CHANGED FROM 100ms)**

**Atomic tick is now 50ms**, not 100ms.

**Why changed:**

- Better timing precision
- Thrust attack (850ms impact) was being skipped with 100ms ticks
- All skill impact ticks must be multiples of 50ms

**Validation:**

```typescript
// GameEngine.ts:185-189
if (impactTick % this.tickInterval !== 0) {
  throw new Error(
    `Invalid skill "${skill.id}": impact tick (${impactTick}) must be a multiple of tick interval (${this.tickInterval}ms)`
  );
}
```

**IMPORTANT:** All comments and documentation referencing "100ms" in old files may be outdated. The current system uses **50ms ticks**.

### 3. **Delayed Tick Interval Start (RECENTLY IMPLEMENTED)**

**Combat timer doesn't start until first action is taken.**

**How it works:**

1. `GameEngine.start()` sets `isRunning = true` but doesn't start the interval
2. Game is in "ready" state, waiting for first action
3. When either PC or NPC calls `executeSkill()`, the 50ms tick interval starts
4. Combat timing begins immediately when first action is taken

**Implementation:**

- `ticksStarted` flag added (GameEngine.ts:41)
- `start()` modified to not start interval (lines 202-216)
- `executeSkill()` starts interval on first action (lines 686-696)
- `stop()` resets `ticksStarted = false` (line 226)

**User request:** "Can we start the intervaltick only when the first action is taken by PC or NPC?"

### 4. **Defense Active Window Checking (FIXED)**

**Defense effectiveness is checked by time window, not current phase.**

**Old bug:** Checked if `defenseAction.currentPhase === 'active'`, which failed if defense action completed before impact.

**Current implementation:**

```typescript
// GameEngine.ts:503-522
private isDefenseActive(defender: FighterState, attackImpactTime: number): boolean {
  const defenseAction = defender.currentAction;
  if (!defenseAction) return false;
  if (defenseAction.skill.type !== 'defense') return false;

  // Defense must be in active phase
  if (defenseAction.currentPhase !== 'active') {
    this.log(`${defender.name} defense not active: currently in ${defenseAction.currentPhase} phase`);
    return false;
  }

  // Basic mode: Any defense in active phase blocks any attack
  // Future: Check linePrediction for Parry, attackPrediction for Deflection
  return true;
}
```

**Note:** The system reminder shows this was reverted back to phase-checking after the user merged changes. The time-based window checking may have been reverted. Double-check the current implementation.

### 5. **Impact Uses TICK Approach, Not Duration**

**Tick is better** for this atomic system.

**JSON format:**

```json
{
  "windUp": { "duration": 400 },
  "committed": { "duration": 800 },
  "impact": { "tick": 1200 }, // ‚Üê Absolute time, NOT duration
  "recovery": { "duration": 800 }
}
```

**Why tick won:**

- Clearer tactical communication: "Attack hits at 1200ms"
- Impact is instant event, not sustained phase
- Telegraphs use absolute times already
- Easier for designers to balance

**Build script validation:** Fails if `impact_tick ‚â† windUp + committed`

### 6. **CSV Build System is the Data Management Layer**

**All combat skills come from CSV files.** JSON files are generated artifacts.

**Workflow:**

1. Edit CSV file (skills as columns for easy comparison)
2. Run `npm run build:skills`
3. Build script generates JSON with auto-calculated values
4. Game engine loads JSON at runtime

**Why CSV as columns:**

```csv
id,overhead_strike,side_slash,thrust
name,Overhead Strike,Horizontal Strike,Thrust
windUp_duration,400,500,250
```

- Easy visual comparison across all skills
- Fast bulk editing in text editor (VSCode)
- Git diff shows what changed

**Build script features:**

- Auto-calculates `impact_tick = windUp + committed`
- Auto-generates `type`, `school`, `stage` numbers
- Dynamically detects telegraph stages (t1, t2, ..., t99+, no limit!)
- Checks for missing assets (warns but doesn't fail)
- Validates timing values (errors on mismatch)
- Validates impact tick alignment with 50ms interval
- Supports attacks, defenses, AND special skills

**File:** `scripts/buildSkills.cjs` (heavily commented, ~580 lines)

### 7. **Defense Skills Have Active Windows, Not Committed Phase**

**Defense structure differs from attacks.**

**Phases:**

- `windUp` - Preparing defense
- `active` - Defense is ready, auto-triggers on impact (NOT committed!)
- `recovery` - Resetting to guard

**CSV format:**

```csv
windUp_duration,100,200,300,300
active_duration,200,400,500,500  # NOT committed_duration!
recovery_duration,500,300,200,200
```

**Defense properties:**

```csv
requiresLine,false,false,true,false
requiresAttackId,false,false,false,true
defenseType,emergency,movement,deflection,deflection
damageReductionPercent,0,1.0,0,0
damageReductionFlat,2,0,3,3
```

**Important:** `damageReductionFlat` is used, not `damageReduction` (old field name).

### 8. **Counter Speed Bonus Implementation Example**

**How windUp modifier works with immutable skill data:**

The skill phases are loaded from JSON and should remain immutable. To apply counter speed bonuses without mutating skill data, we use a modifier pattern:

**Step 1: Store bonus on FighterState after successful defense**

```typescript
// In resolveImpact() after successful parry/deflection (GameEngine.ts:481-485)
if (defenseProps?.counterSpeedBonus) {
  defender.activeCounterBonus = defenseProps.counterSpeedBonus; // 100ms or 300ms
  this.log(
    `${defender.name} gains ${defenseProps.counterSpeedBonus}ms counter bonus!`
  );
}
```

**Step 2: Apply bonus as negative modifier in executeSkill()**

```typescript
// Before creating action in executeSkill() (GameEngine.ts:703-711)
let windUpModifier = 0;
if (fighter.activeCounterBonus && skill.type === "attack") {
  windUpModifier = -fighter.activeCounterBonus; // Negative = faster
  this.log(
    `${fighter.name} uses ${fighter.activeCounterBonus}ms counter bonus: windUp ${skill.phases.windUp.duration}ms ‚Üí ${skill.phases.windUp.duration + windUpModifier}ms`
  );
  fighter.activeCounterBonus = undefined; // Clear after use
}

// Store in action (GameEngine.ts:722)
fighter.currentAction = {
  // ... other fields
  windUpModifier, // -100 or -300
};
```

**Step 3: Apply modifier in phase calculations**

```typescript
// In updatePhaseProgression() for attacks (GameEngine.ts:355-356)
const windUpEnd = skill.phases.windUp.duration + (action.windUpModifier || 0);
const impactTick = skill.phases.impact.tick + (action.windUpModifier || 0);
// Example: 500ms windUp + (-300ms modifier) = 200ms actual windUp
```

**Result:** A deflection with 300ms counter bonus reduces next attack windUp from 500ms ‚Üí 200ms, giving a massive riposte advantage, while keeping the original `skill.phases.windUp.duration = 500` immutable.

**Key Design Decision:** Bonus is cleared on ANY new action (not just attacks), which encourages immediate counter-attacks and simplifies the logic.

### 9. **Fighter Names Changed in GameEngine**

**PC:** "Player" ‚Üí "Mizhael"
**NPC:** "Opponent" ‚Üí "Bandit"

This was changed in the constructor:

```typescript
// GameEngine.ts:66-67
this.pc = this.createFighter("pc", "Mizhael");
this.npc = this.createFighter("npc", "Bandit");
```

### 10. **Both Fighters Manually Controlled (For Now)**

**No AI yet.** User simulates both fighters to test mechanics.

PC actions on left, NPC actions on right. This is intentional for prototyping.

### 11. **UI Layout is 3-Column**

**Changed from stacked layout to side-by-side.**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ PC Actions  ‚îÇ  Center Content  ‚îÇ NPC Actions ‚îÇ
‚îÇ  (left)     ‚îÇ  (Timeline, Log) ‚îÇ  (right)    ‚îÇ
‚îÇ  w-64       ‚îÇ    flex-1        ‚îÇ  w-64       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**ActionPanel.tsx** accepts `fighter` prop:

```typescript
<ActionPanel fighter="pc" ... />
<ActionPanel fighter="npc" ... />
```

**Tailwind warning:** Don't use template literals for dynamic classes!

```typescript
// WRONG - purged at build time
className={`text-${color}-400`}

// RIGHT - conditional expressions
className={fighter === 'pc' ? 'text-green-400' : 'text-red-400'}
```

**Modal Components Pattern:** Always use React Portals for modal overlays!

```typescript
// REQUIRED - Use createPortal to render modals at document.body
import { createPortal } from 'react-dom';

export function MyModal({ isOpen, onClose }: Props) {
  if (!isOpen) return null;

  const modalContent = (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[9999]" onClick={onClose}>
      <div className="bg-gray-800 rounded-lg p-6 max-w-md w-full" onClick={(e) => e.stopPropagation()}>
        {/* Modal content */}
      </div>
    </div>
  );

  return createPortal(modalContent, document.body);
}
```

**Why React Portals?**

- Escapes parent component stacking contexts
- Ensures modal appears above ALL UI elements regardless of z-index
- Prevents z-index layering issues with sticky/relative positioned parents
- Standard pattern used in: `LineSelectionModal`, `AttackPredictionDropdown`, `FeintSelectionModal`

### 12. **Skill Renaming: slash ‚Üí side_slash**

**Old name:** slash
**New name:** side_slash

**Updated in:**

- CSV: `id` column value
- JSON filename: `side_slash.json`
- GameEngine.ts: skill loading (3 references)
- ActionPanel.tsx: button references

**Pattern for future renames:**

1. Update CSV `id` row
2. Run `npm run build:skills`
3. Search codebase for old name
4. Update all references

---

## üèóÔ∏è Architecture Patterns

### CSV Build System Flow:

```
CSV Files (source of truth)
  ‚Üì npm run build:skills
buildSkills.cjs
  ‚Üì parseCSV()
  ‚Üì detectTelegraphStages()
  ‚Üì buildAttackSkill() / buildDefenseSkill() / buildSpecialSkill()
  ‚Üì validateSkill()
  ‚Üì checkAssets()
JSON Files (generated)
  ‚Üì fetch at runtime
GameEngine.loadSkills()
```

### Event-Driven Game Loop:

```
GameEngine (pure TypeScript, no React)
  ‚Üì emits events every tick
React Components
  ‚Üì re-render
UI updates
```

**Key insight:** Engine has zero React dependencies. UI is just a listener.

### Atomic Tick Loop:

```typescript
// GameEngine.ts:246-270
private tick(): void {
  if (this.pauseState.isPaused) return;

  this.currentTick += this.tickInterval; // Advance time by 50ms

  this.updateFighter(this.pc);
  this.updateFighter(this.npc);

  this.emitStateUpdate(); // ‚Üí React
}
```

**Tick interval only starts when first action is taken!**

Everything happens in 50ms increments. Deterministic, no RNG.

### Phase Progression:

```typescript
// Attack: windUp ‚Üí committed ‚Üí impact ‚Üí recovery
if (elapsed < windUpEnd) ‚Üí windUp
else if (elapsed < impactTick) ‚Üí committed
else if (elapsed === impactTick) ‚Üí impact (ONE tick only!)
else if (elapsed < recoveryEnd) ‚Üí recovery
else ‚Üí action complete, clear it

// Defense: windUp ‚Üí active ‚Üí recovery
if (elapsed < windUpEnd) ‚Üí windUp
else if (elapsed < activeEnd) ‚Üí active
else if (elapsed < recoveryEnd) ‚Üí recovery
else ‚Üí action complete, clear it
```

Impact resolves **once** when entering impact phase (using prevPhase check).

---

## üîß Current Skill Inventory

### ‚úÖ Implemented Skills (10 total):

**Attacks (5):**

1. `overhead_strike` - Vertical overhead, high line, 400ms windUp, 2000ms total
2. `side_slash` - Horizontal slash, horizontal line, 500ms windUp, 2100ms total
3. `thrust` - Forward stab, center line, 250ms windUp, 1550ms total (fastest)
4. `upward_strike` - Rising attack, low line, 400ms windUp, 2000ms total
5. `diagonal_slash` - Angled cut, diagonal line, 600ms windUp, 2500ms total (slowest)

**Defenses (4):**

1. `emergency_defense` - Last resort, 100ms windUp, 2 flat reduction, 500ms recovery
2. `retreat` - Movement, 200ms windUp, 100% reduction (full dodge), 300ms recovery
3. `parry` - Line-based block, 300ms windUp, 3 flat reduction, requires correct line, 200ms recovery
4. `deflection` - Attack prediction block, 300ms windUp, 3 flat reduction, requires attack ID, 200ms recovery

**Special (1):**

1. `feint` - Attack morph, reads defender telegraph, 100ms penalty, 1.4x stamina cost

**All attacks deal 3 base damage. All skills have 4-stage telegraphs.**

### üìä Skill Balance (50ms tick system):

**Fastest attack:** thrust (250ms windUp, 850ms impact, 1550ms total)
**Slowest attack:** diagonal_slash (600ms windUp, 1900ms impact, 2500ms total)
**Fastest defense:** emergency_defense (100ms windUp = very late reaction)
**Shortest recovery:** parry & deflection (200ms = riposte opportunity)

---

## üêõ Past Issues Solved (Don't Repeat)

1. **Tailwind CSS v4 incompatibility** - Locked to v3.4.17, never upgrade
2. **Duration vs Tick for impact** - Tick won (see section 5)
3. **Thrust not doing damage** - Fixed by changing tick interval from 100ms to 50ms
4. **Impact timing precision** - Added validation: impact_tick % tickInterval === 0
5. **Legacy clean hit system** - Completely removed from all files
6. **hitsRemaining field** - Removed from FighterState interface
7. **Defense timing bug** - Fixed isDefenseActive() to check time window (note: may be reverted to phase checking)
8. **Dynamic class names in Tailwind** - Use conditionals, NOT template literals
9. **Timeline bars shrinking** - Fixed with overlaid text
10. **Duplicate JSON files** - Old capitalized names removed

---

## üìã Known Limitations & Next Steps

### ‚ö†Ô∏è Current Limitations:

- **No asset files** - All telegraphs use placeholder.png
- **Manual fighter control** - No NPC AI yet
- **No visual telegraphs** - Only combat log messages
- **Feint not implemented in engine** - JSON exists but logic not in GameEngine.ts
- **Defense prediction not implemented** - Parry line selection, deflection attack selection UI missing
- **No combo system** - Each skill is independent
- **Defense active window checking may be phase-based** - Time-based window was implemented but appears to have been reverted

### üéØ Likely Next Requests:

**High Priority:**

1. Verify defense active window checking (time-based vs phase-based)
2. Implement parry line selection UI
3. Implement deflection attack prediction UI
4. Implement feint mechanics in GameEngine.ts
5. Add visual telegraph indicators (images/animations)
6. Create actual telegraph assets (replace placeholders)

**Medium Priority:** 7. NPC AI decision tree 8. Combo system (skill chaining) 9. More attack/defense skills 10. Counter attack system (use counterSpeedBonus from defense properties)

**Lower Priority:** 11. UI polish/animations 12. Sound effects 13. Skill unlock progression 14. Tutorial/tooltips

**User might ask to:**

- Adjust CSV timing values and rebuild
- Add new skills via CSV
- Balance stamina costs
- Change telegraph trigger times
- Add new special skills
- Fix defense timing logic
- Test combat mechanics

---

## üéØ What User Cares About

### High Priority:

- **CSV workflow** - Easy skill balancing without touching code
- **Combat feel** - Timing must be clear and fair
- **HP-based damage system** - Simple, deadly, tactical
- **Telegraph system** - Reading and counter-reading telegraphs
- **No RNG** - Everything deterministic
- **Learning TypeScript** - User wants to understand how it works

### Less Priority (For Now):

- UI polish/animations
- React patterns/best practices
- Performance optimization
- Code organization/refactoring
- Documentation (unless requested)

**User's words:** "TypeScript is a must. I want to understand how it works. Then UI is secondary I just want it to work."

---

## üí° Working With This User

**Communication style:**

- Prefers concise, accurate explanations
- Will edit CSV/code files directly
- Likes seeing options/trade-offs before choosing
- Values technical accuracy over validation
- New to TypeScript, appreciates clear type explanations

**When explaining code:**

- Show file path with line numbers: `GameEngine.ts:245`
- Explain TypeScript types clearly
- Reference design docs by name
- Use examples from actual codebase
- Mention if reading docs would help

**Red flags (DON'T do this):**

- ‚ùå Don't create documentation files unprompted
- ‚ùå Don't refactor unless asked
- ‚ùå Don't add emojis unless requested
- ‚ùå Don't guess at URLs
- ‚ùå Don't update git without being asked

**User instructions from CLAUDE.md:**

1. Double-check things, be skeptical, do research
2. User is not always right (neither are you)
3. Stick to React best practices (avoid unnecessary effects)

---

## üîç Quick Reference

### File Locations:

**Engine:** `src/engine/GameEngine.ts` (~811 lines)
**Types:** `src/types/CombatTypes.ts` (all interfaces)
**Build script:** `scripts/buildSkills.cjs` (~580 lines, heavily commented)
**React entry:** `src/components/CombatScene.tsx` (3-column layout)
**Action panel:** `src/components/Actions/ActionPanel.tsx` (accepts `fighter` prop)

### Key Functions:

**Main loop:** `GameEngine.tick()` - runs every 50ms (when started)
**Phase update:** `GameEngine.updatePhaseProgression()` - checks elapsed time
**Impact resolution:** `GameEngine.resolveImpact()` - applies damage formula
**Defense check:** `GameEngine.isDefenseActive()` - checks defense effectiveness
**Skill execution:** `GameEngine.executeSkill()` - starts tick interval on first action
**Auto-pause:** `GameEngine.checkAutoPause()` - uses telegraph.pause field
**Skill loading:** `GameEngine.loadSkills()` - fetches JSON from `/public/CombatSkills/`

### Build Commands:

```bash
npm run dev              # Start dev server
npm run build:skills     # Rebuild all skills from CSV
npm run validate:skills  # Validate CSV without writing
```

### Timing Reference:

**Tick rate:** 50ms (20 ticks per second)
**Fastest attack:** thrust (250ms windUp, 850ms impact, 1550ms total)
**Slowest attack:** diagonal_slash (600ms windUp, 1900ms impact, 2500ms total)
**Emergency defense:** 100ms windUp (last resort timing)
**Parry/Deflection recovery:** 200ms (shortest, enables riposte)

### Damage Reference:

**HP:** 3 for both PC and NPC
**Base damage:** 3 for all attacks
**Death:** HP <= 0
**Formula:** `finalDamage = attackDamage * (1 - damageReductionPercent) - damageReductionFlat`

**Defense reductions:**

- Emergency Defense: 2 flat ‚Üí 1 damage taken
- Retreat: 100% reduction ‚Üí 0 damage
- Parry: 3 flat ‚Üí 0 damage
- Deflection: 3 flat ‚Üí 0 damage

---

## ü§ù Good Luck!

The codebase is clean, well-commented, and working. The HP-based damage system is fully implemented. The 50ms tick system provides precise timing. The CSV build system makes skill iteration fast. The user is engaged and gives clear feedback.

**Start here:**

1. Read `CLAUDE.md` - User instructions
2. Read `Combat3 - atomic_turns.md` - Understand the phase system
3. Read `PRD.md` - Understand current implementation (lines 182-203 for damage system)
4. Read `CombatTypes.ts` - Understand data model
5. Read `GameEngine.ts` - Core combat logic (focus on lines 441-497, 503-522, 686-696)
6. Read `public/CombatSkills/README.md` - CSV workflow

**Most important recent changes:**

- HP-based damage system (3 HP, 3 damage, death at HP <= 0)
- 50ms tick interval (changed from 100ms)
- Delayed tick interval start (combat timer starts on first action)
- Defense active window checking (verify if time-based or phase-based)
- Legacy "clean hit" system completely removed

**When in doubt:**

- Check the CSV files to see data structure
- Read buildSkills.cjs comments for build logic
- Check CombatTypes.ts for type definitions
- Look at generated JSON for expected format
- Read GameEngine.ts for implementation details
- Test in the running prototype (npm run dev)
